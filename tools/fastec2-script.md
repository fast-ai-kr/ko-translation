# fastec2 script: 오랫동안-수행되는 작업을 실행하고 모니터링 하기
> 작성일: 2019년 2월 15일, 작성자: Jeremy Howard

_이 글은 fastec2에 관한 시리즈의 파트2에 해당하는 것이다. fastec2에 대한 소개내용을 위해서는 [파트1](./fastec2.md)을 읽어봐주길 바란다._

Spot 인스턴스는 오랫동안 수행되는 작업종류에 특히 좋다. 왜냐하면, 돈을 많이 절약할 수 있고, 무거운 계산을 요하는 작업이 필요할때만 더 비싼 인스턴스 종류를 사용할 수 있기 때문이다. fastec2에는 이러한 사용의 예를 보다 편리하게 해 줄수 있는 기능이 있다. 구체적인 예를 통해서 확인해보자. 아래는 구체적인 예를 통해서 수행하게될 내용을 나열한다:

1. 결과의 수집을 위해서 요청에의한, 저렴한 모니터링용 인스턴스를 사용한다 (선택적으로 어떤 작업을 실행할 수도 있다). 가이드내에서 이 인스턴스를 `od1` 이라 부르기로한다 (하지만, 여러분이 원하는 어떤 이름을 사용해도 상관은 없다).

2. 요구되는 작업을 수행하는 스크립트를 만들고, 스크립트의 설정 파일들을 특정 폴더에 넣어둔다. 스크립트는 특정 폴더내에 결과를 저장해야할 필요가 있다.

3. 스크립트가 정상 동작하는지, 깨끗한(fresh) 인스턴스에서 이를 테스트한다.

4. fastec2을 사용해서 스크립트를 실행한다. fastec2는 스크립트가 새로운 인스턴스의 tmux 세션내에서 실행되게끔 한다. 이 인스턴스는 `od1`으로, 필요한 파일들이 복사되어져 있을뿐만 아니라 발생되는 모든 결과도 모두 복사되어 저장된다.

5. 스크립트가 실행되는 동안, 스크립트가 실행중인 tmux 세션에 연결하여 프로그레스를 확인하거나 `od1`으로 복사되어져온 결과를 봄으로써 확인한다.

6. 스크립트의 수행이 완료되면, 스크립트를 수행하는 인스턴스는 자동으로 종료(삭제)되고 모든 결과를 `od1`에서 리뷰한다.

위의 일련의 작업들이 동작하는 상세내용과 어떻게 사용할 수 있는지를 살펴보자. 이 글의 나중부분에서는 fastec2의 볼륨과 스탭샷 기능을 사용하여 거대한 데이터셋에 손쉽게 연결하기 위한 방법을 살펴보게 될 것이다.

## 모니터링을 위한 인스턴스와 스크립트를 설정하기

첫 번째로, 원하는 작업을 완수할 수 있는 스크립트의 작성한다. fastec2로 스크립트를 실행할 때, 스크립트는 `~/fastec2` 디렉토리 내에서 실행되고, 이 디렉토리는 스크립트 실행에 필요한 (AMI에 들어있지 않은)추가적인 파일들을 포함해야 하고, (이 가이드에서 `od1`이라 칭한)요청에의한 인스턴스로 모니터링된 변경 사항들이 복사된다. 아래는 테스트를 위한 `myscript.sh` 라는 파일의 예를 보여준다:

```console
#!/usr/bin/env bash
echo starting >> $FE2_DIR/myscript.log
sleep 60
echo done >> $FE2_DIR/myscript.log
```

이 스크립트가 실행될 때, `FE2_DIR`라는 환경변수는 스크립트와 파일이 들어있는 디렉토리 위치를 저장하게된다. 아래와같이 스크립트에게 실행가능 권한의 부여가 필요함을 기억해 두자:

```console
$ chmod u+x myscript.sh
```

깨끗한 인스턴스에서 테스트할 때, `FE2_DIR`가 저장할 디렉토리를 생성하고 `FE2_DIR`에 이를 저장한다. 그리곤, 스크립트가 정상 동작하는지를 확인 해 본다 (빠르게 테스트해보기 위한 몇 파라메터를 스크립트내 설정해두는것도 좋은 생각이다).

```console
$ export FE2_DIR=~/fastec2/spot2
$ mkdir -p $FE2_DIR
$ ./myscript.sh
```

## fastec2로 스크립트를 실행하기

오랫동안 실행중인 스크립터의 결과를 수집하는데 사용될 컴퓨터가 필요하다. 이 컴퓨터에는 Spot 인스턴스가 적절치 못한데, 그 이유는 Spot 인스턴스가 언제든지 강제 종료되어 수집된 결과가 유실될 수 있기 때문이다. 하지만 Spot 인스턴스는 저렴한 종류이긴 하다. 1년 이내로 생성한 AWS 계정이 있다면, `t2.micro` 인스턴스를 무료로 사용할 수 있다. 그렇지 않다면 `t3.micro`가 좋은 선택이 된다 - 이 인스턴스는 실행중인 동안 약 월당 US$7 정도의 비용이 발행한다 (이 때 스토리지에 대한 가격은 별도).

fastec2로 스크립스를 실행하기 위해서, 다음과 같은 정보를 제공해야한다:

1. 사용하고자 하는 인스턴스에 이름을 붙여준다 (우선 `launch`로 생성을 해야한다).

2. 스크립트에 이름을 붙여준다.

3. `([--myip MYIP] [--user USER] [--keyfile KEYFILE])`와 같은 추가적인 인자값을 설정해서, 결과를 복사하고자 하는 모니터링 인스턴스에 연결한다. 호스트( `MYIP` )가 제공되지 않는다면, `fe2`가 실행중인 컴퓨터의 IP를 사용한다. 

예를들어서 아래의 명령어는 `myscript.sh`를 `spot2`에서 실행하고, 스크립트의 결과를 `18.188.16.203`으로 저장한다.

```console
$ fe2 launch spot2 base 80 m5.large --spot
$ fe2 script myscript.sh spot2 18.188.162.203
```

아래는 바로 위의 fe2 launch 를 실행한 이후 어떤일이 발생하는지를 나열한다:

1. `~/fastec2/spot2` 라는 디렉토리가 모니터링 인스턴스에서 아직 존재하지 않을 때 생성된다 (항상 `~/fastec2` 의 하부 디렉토리로 존재하고, 디렉토리의 이름은 연결하는 인스턴스의 이름과 동일하다. 위 예의 경우에는 spot2가 사용되었다).

2. 스크립트는 `~/fastec2/spot2` 디렉토리로 복사된다.

3. `~/fastec2/spot2` 디렉토리는 타겟 인스턴스 (`spot2`) 로 복사된다.

4. `~/fastec2/current` 라는 파일이 타겟 인스턴스에서 생성되고, 이 파일은 작업의 이름을 포함한다 (위 예의 경우, spot2가 사용되었다).

5. lsyncd 타겟 인스턴스의 백그라운드에서 실행되어 지속적으로 `~/fastec2/spot2` 디렉토리내에 새로생기거나 변화가 발생하는 파일을 모니터링 인스턴스로 복사한다.

6. `~/fastec2/spot2/myscript.sh`는 tmux 세션내에서 실행된다.

스크립트가 완료된 후 인스턴스의 종료를 원한다면, 스크립트의 마지막에 (Ubuntu 의 경우)`systemctl poweroff` 또는 이와 유사한기능을 하는 명령을 포함시켜야함을 기억해두자.

## 데이터 볼륨을 생성하기

앞선 수행한 작업의 한 가지 문제점이 있는데, 여러개의 거대한 데이터셋이 존재할 때, 이 모든것을 사용하고자 하는 각각의 AMI로 복사할 필요가 있다는것이다 (비싸다. 즉, 데이터셋을 추가할 때 마다 AMI을 재생성 해야한다는 의미). 또는 각각의 데이터셋에 대한 별도의 새로운 AMI를 생성해야 할지도 모른다 (설정을 변경하거나 애플리케이션을 추가함에 따라 모든 AMI도 변경되야 함을 의미).

손쉬운 방법은 데이터셋을 별도의 볼륨(AWS 디스크)에 넣어주는 것이다. fastec2는 볼륨을 손쉽게 만들 수 있도록 해준다 (ext4 형식으로 포맷된, 리눅스 파일시스템의 가장 흔한 종류). 이렇게 하기 위해서, 새로운 볼륨을 포맷하고 마운팅하기 위해 인스턴스로 연결하기 위한 ssh 객체가 필요하기 때문에, fastec2 REPL (파트1의 REPL에 대한 소개 내용을 참고)을 사용하는것이 가장 쉬운 방법일 것이다. 예를 들어서, (이미 실행중인)`od1` 인스턴스를 사용해서 볼륨을 생성하고자 한다면:

```python
$ fe2 i
IPython 6.1.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]: inst = e.get_instance('od1')

In [2]: ssh = e.ssh(inst)

In [3]: vol = e.create_volume(ssh, 20)

In [4]: vol
Out[4]: od1 (vol-0bf4a7b9a02d6f942 in-use): 20GB

In [5]: print(ssh.run('ls -l /mnt/fe2_disk'))
total 20
-rw-rw-r-- 1 ubuntu ubuntu     2 Feb 20 14:36 chk
drwx------ 2 ubuntu root   16384 Feb 20 14:36 lost+found
```

보시다시피 새로운 디스크가 요청된 인스턴스의 `/mnt/fe2_disk` 디렉토리에 마운팅 되었고, 새로운 볼륨에는 볼륨이 생성된 인스턴스와 동일한 이름( `od1` )이 부여되었다. 이제부터 인스턴스에 연결하여 데이터셋을 이 디렉토리로 복사할 수 있다. 그리고 하고자 하는 작업이 완료된 후, 볼륨의 마운트를 해제하고 (ssh 세션에서 `sudo umount /mnt/fe2_disk in your ssh session`), fastec2를 사용하여 볼륨을 떼어낼 수 있다. 직전에 열어둔 REPL 세션이 없다면, 볼륨객체를 우선적으로 가져오고난 후 떼어낼 수 있다.

```python
In [1]: vol = e.get_volume('od1')

In [2]: vol
Out[2]: od1 (vol-0bf4a7b9a02d6f942 in-use): 20GB

In [3]: e.detach_volume(vol)

In [4]: vol
Out[4]: od1 (vol-0bf4a7b9a02d6f942 available): 20GB
```

향후에는 REPL을 통해서, 볼륨을 다시 마운팅할 수도 있게될 것이다:

```python
In [5]: e.mount_volume(ssh, vol)

```

## 스냅샷을 사용하기

볼륨의 가장 심각한 좋지못한점은 한 시점에 하나의 인스턴스에만 붙여줄 수 있다는 것이다. 즉, 볼륨을 사용하면 동일한 데이터셋에 연결된 여러개의 작업을 실행하는 것이 불가능 하다는 것이다. 대신에, 이 경우에는 스냅샷을 생성해야만 한다. 스냅샷이란 볼륨에 대한 템플릿으로, 스냅삿으로부터 생성된 볼륨들은 모두 원본 볼륨이 가지고 있던 데이터를 가지게 된다. 스냅샷들은 볼륨에 추가되는 어떤 추가적인 정보로 업데이트되지 않음을 알아두자 - 스냅샷에 포함된 원본 데이터는 어떠한 변화도 없이 그대로 남겨진다.

볼륨의 스냅샷을 생성하기 위해서는 (`vol` 이라는 볼륨 객체가 이미 있고, 인스턴스로부터 떼어냈다고 가정한다):

```python
In [7]: snap = e.create_snapshot(vol, name="snap1")
```

그러면, 스냅샷을 사용해서 자동으로 인스턴스로 붙여질 수 있는 볼륨을 생성할 수 있다:

```python
In [8]: vol = e.create_volume(ssh, name="vol1", snapshot="snap1")
```

## 요약

지금까지 궁금증에 대한 모든 내용이 다뤄졌다. 앞으로의 포스팅에서는 fastec2을 사용해서 수행하는 작업에 대한 최선의 사용예를 다룰것이다. 어쨋거나 아래에는 프로세스에 대한 간단한 요약을 보여준다:

1. 인스턴스를 실행하고, 필요한 설정과 소프트웨어로 셋업한다.
2. 필요하다면 데이터셋에 대한 볼륨을 생성하고, 스냅샷을 만든다.
3. 인스턴스를 멈추고, 해당 인스턴스에 대한 AMI를 생성한다 (선택적으로, 인스턴스를 종료(삭제)해도 무방하다).
4. 저렴한 인스턴스 종류로, 모니터링 인스턴스를 실행한다.
5. 오랫동안-수행되는 작업에대한 spot 인스턴스를 실행한다.
6. 스냅샷으로 볼륨을 생성하고, spot 인스턴스로 붙여준다.
7. 오랫동안-수행되는 잘업을 실행하고, 이 때 모니터링 인스턴스의 IP를 넘겨준다.
8. 오랫동안-수행되는 작업이 완료될 때 인스턴스가 멈춰지게끔 해서 추가적인 비용이 발생하지 않도록 한다 (또한 스냅샷으로부터 생성된 볼륨을 삭제하고 싶을수도 있을것다).

추가적인 작업을 실행하기 위해서, 마지막 4개의 과정만을 반복하면 된다. 본 가이드에서 보여준 API 호출을 사용하면 프로세스를 자동화하는것도 가능하다.

